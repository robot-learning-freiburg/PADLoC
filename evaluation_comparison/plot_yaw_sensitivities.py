from argparse import ArgumentParser
from collections import namedtuple
from pathlib import Path
from typing import Dict, List, NoReturn, Optional, Union

from matplotlib import pyplot as plt
import numpy as np
import pickle

PathLike = Union[Path, str]

StatFile = namedtuple("StatFile", ["label", "path"])
Plot = namedtuple("Plot", ["title", "x_label", "y_label", "stat_key"])
Curve = namedtuple("Curve", ["label", "x", "y"])


def plot_curve(ax: plt.Axes, *,
               x: list, y: list,
               label: str, bounds: str = "std"
               ) -> NoReturn:

    x = np.array(x)
    y = np.array(y)
    y = np.abs(y)

    mean = y.mean(axis=1)

    low_bound = high_bound = None

    if bounds == "std":
        std = y.std(axis=1)

        low_bound = mean - std
        high_bound = mean + std

    if bounds == "quartile":
        low_bound = np.quantile(y, 0.25, axis=1)
        high_bound = np.quantile(y, 0.75, axis=1)

    if bounds == "min_max":
        low_bound = np.min(y, axis=1)
        high_bound = np.max(y, axis=1)

    if low_bound is not None and high_bound is not None:
        ax.fill_between(x, low_bound, high_bound, alpha=0.2)

    ax.plot(x, mean, label=label)


def plot(curves: List[Curve], *,
         x_label: str, y_label: str, plot_title: str,
         dpi: int = 300, bounds: str = "std",
         save_path: Optional[PathLike] = None,
         show: bool = False
         ) -> NoReturn:

    fig, ax = plt.subplots(dpi=dpi)

    ticks = set()
    for c in curves:
        if c.x is None or c.y is None:
            continue

        ticks = ticks.union(c.x)
        plot_curve(ax, x=c.x, y=c.y, label=c.label, bounds=bounds)

    ax.set(xlabel=x_label, ylabel=y_label)
    ax.set_title(plot_title)
    ax.set_xticks(np.array(list(ticks)))
    ax.legend()

    if save_path is not None:
        print(f"Saving plot to file {save_path}.")
        plt.savefig(save_path)

    if show:
        plt.show()

    plt.close(fig)


def load_stats(path: PathLike
               ) -> Dict:
    with open(path, "rb") as f:
        stats = pickle.load(f)

    return stats


def build_curve(curve_label: str, *,
                key: str, stats: dict
                ) -> Curve:

    if key not in stats:
        x = y = None
    else:
        x = list(stats[key].keys())
        y = list(stats[key].values())

    return Curve(label=curve_label, x=x, y=y)


def main(stat_file_path: Path,
         save_path: Path,
         extension: str = "pdf", bounds: str = "std"
         ) -> NoReturn:

    save_path.mkdir(parents=True, exist_ok=True)

    stats_files = [
        # DL Models
        StatFile("PADLoC", stat_file_path / "padloc_220527191054" / "lastiter" / "kitt" / "reg" /
                 "eval_reg_padloc_220527191054_lastiter_kitt_seq_08.pickle"),
        StatFile("LCDNet", stat_file_path / "lcdnet_210916000234" / "lastiter" / "kitt" / "reg" /
                 "eval_reg_lcdnet_210916000234_lastiter_kitt_seq_08.pickle"),
        StatFile("DCP",    stat_file_path / "dcp_220404183414" / "lastiter" / "kitt" / "reg" /
                 "eval_reg_dcp_220404183414_lastiter_kitt_seq_08.pickle"),

        # Baselines
        StatFile("SC", stat_file_path / "baselines" / "sc" / "kitt" / "reg" /
                 "eval_reg_sc_kitt_seq_08.pickle"),  # Generated by [DC]
    ]

    plots_cfg = [
        Plot("Mean Rotational Error",             "Yaw [º]", "Error [º]",  "pair_err_yaw_deg"),
        Plot("Mean Translational Error",          "Yaw [º]", "Error [m]",   "pair_err_tra"),
        Plot("Descriptor Distance (Pos to Anc)",  "Yaw [º]", "L2 Distance", "desc_ancpos_l2_dist"),
        Plot("Descriptor Distance (Pos to Pos0)", "Yaw [º]", "L2 Distance", "desc_pos0posth_l2_dist"),
    ]

    stats = {f.label: load_stats(f.path) for f in stats_files}

    for p in plots_cfg:
        curves = [build_curve(k, key=p.stat_key, stats=v) for k, v in stats.items()]

        plot_path = "_".join(p.title.lower().split(" ")) + "." + extension
        plot_path = save_path / plot_path

        plot(curves, x_label=p.x_label, y_label=p.y_label,
             plot_title=p.title, bounds=bounds, save_path=plot_path)


def cli_args() -> dict:
    parser = ArgumentParser()

    parser.add_argument("--stat_file_path", type=Path,
                        default=Path("/mnt/swork/res/yaw_sensitivity/"))
    parser.add_argument("--save_path", type=Path,
                        default=Path("/home/arceyd/Documents/Projects/PADLoC/img/yaw_sensitivity/"))
    parser.add_argument("--bounds", choices=["std", "quartile", "min_max", "none"], default="std")
    parser.add_argument("--extension", default="pdf")

    args = parser.parse_args()

    return vars(args)


if __name__ == "__main__":
    main(**cli_args())
